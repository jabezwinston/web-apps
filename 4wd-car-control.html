<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4WD Car WebBLE Controller</title>
    <style>
        :root {
            --bg: #0f1115;
            --card: #151922;
            --text: #e6e9ef;
            --muted: #9aa3b2;
            --border: #232938;
            --accent: #4f8cff;
            --accent-2: #30c48d;
            --danger: #ef5350;
            --btn-bg: #1b2130;
            --btn-hover: #232a3b;
        }
        @media (prefers-color-scheme: light) {
            :root {
                /* Slightly darker "light" theme */
                --bg: #e9ecf4;
                --card: #f6f8fc;
                --text: #0b1020;
                --muted: #586174;
                --border: #d8deea;
                --accent: #275cd6;
                --accent-2: #109a6c;
                --danger: #d94343;
                --btn-bg: #e6eaf3;
                --btn-hover: #dfe5f0;
            }
        }
        html, body { height: 100%; }
        body {
            margin: 0; padding: 24px;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            color: var(--text);
            background: radial-gradient(1200px 800px at 10% 0%, #151a23 0%, var(--bg) 45%), var(--bg);
        }
        .container { width: 100%; margin: 0 auto; }
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 18px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
        }
        h2 { margin: 4px 0 12px; font-weight: 600; font-size: 20px; letter-spacing: 0.2px; }
        .row { display: flex; gap: 12px; align-items: center; margin: 10px 0; }
        .row.stack { flex-direction: column; align-items: stretch; }
        .controls {
            display: grid;
            grid-template-columns: 84px 84px 84px;
            grid-template-rows: 84px 84px 84px;
            gap: 10px; align-items: center; justify-content: center;
        }
        button {
            padding: 10px 12px; min-width: 80px; min-height: 40px; font-size: 14px;
            color: var(--text); background: var(--btn-bg);
            border: 1px solid var(--border); border-radius: 12px;
            transition: background 0.15s ease, transform 0.05s ease;
        }
        button:hover { background: var(--btn-hover); }
        button:active { transform: translateY(1px); }
        #connectButton { background: linear-gradient(180deg, var(--accent-2), #1a9b70); border: none; }
        #disconnectButton { background: linear-gradient(180deg, var(--danger), #c53b37); border: none; }
        #disconnectButton:disabled, #connectButton:disabled { filter: grayscale(35%); opacity: 0.7; }
        .dpad button { min-width: 84px; min-height: 84px; font-size: 18px; border-radius: 14px; }
		.icon-btn { width: 48px; height: 48px; min-width: 48px; min-height: 48px; padding: 8px; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 22px; }
		.icon { width: 22px; height: 22px; fill: var(--text); opacity: 0.92; }
		.icon-btn:hover .icon { opacity: 1; }
        .fullwidth { width: 100%; }
        .status { font-size: 13px; color: var(--muted); }
        .tag { display: inline-block; background: var(--btn-bg); padding: 2px 8px; border-radius: 10px; margin-left: 8px; font-size: 12px; border: 1px solid var(--border); color: var(--muted); }
        .hint { font-size: 12px; color: var(--muted); }
        hr { border: 0; height: 1px; background: var(--border); margin: 14px 0; }
        input[type="range"] { accent-color: var(--accent); }
        textarea { background: var(--btn-bg); color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 8px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h2>4WD Car Controller</h2>

    <div class="row">
        <button id="connectButton">Connect</button>
        <button id="disconnectButton" disabled>Disconnect</button>
        <span id="connectionStatus" class="status">Not connected</span>
    </div>

    <div class="row">
        <label for="speedRange"><strong>Speed</strong></label>
        <input type="range" id="speedRange" min="0" max="255" step="1" value="160" class="fullwidth">
        <span id="speedValue" class="tag">160</span>
    </div>

    <div class="row dpad" style="margin-top: 16px;">
        <div class="controls">
            <div></div>
            <button id="btnUp">â–²</button>
            <div></div>
            <button id="btnLeft">â—€</button>
            <button id="btnBrake">â– </button>
            <button id="btnRight">â–¶</button>
            <div></div>
            <button id="btnDown">â–¼</button>
            <div></div>
        </div>
    </div>

    <div class="row" style="margin-top: 12px;">
        <button id="btnHeadlamp" class="icon-btn" title="Headlamp" disabled>ðŸ’¡</button>
        <button id="btnHorn" class="icon-btn" title="Horn" disabled>ðŸ“£</button>
        <span id="capabilities" class="status"></span>
    </div>

    <hr>

    <div class="row" style="flex-wrap: wrap;">
        <span id="gamepadStatus" class="status">No gamepad</span>
    </div>
    <div class="row" style="flex-wrap: wrap; gap: 24px; font-size: 13px;">
        <div>
            <div><strong>Steer</strong>: Axis 0 (wheel)</div>
            <div><strong>Throttle</strong>: RT (button 7) or Axis 5</div>
            <div><strong>Brake/Reverse</strong>: LT (button 6) or Axis 2</div>
        </div>
        <div>
            <div><strong>Headlamp</strong>: X (button 2) on press</div>
            <div><strong>Horn</strong>: B (button 1) hold</div>
        </div>
    </div>

    <div class="row stack" style="margin-top: 12px; width: 100%;">
        <label for="gamepadDebug" class="hint"><strong>Gamepad debug</strong></label>
        <textarea id="gamepadDebug" rows="6" style="width: 100%; font-family: monospace;" readonly></textarea>
    </div>

        </div>
    </div>
    <script>
        const CONTROL_SERVICE_UUID = '4fafc201-1fb5-459e-8fcc-c5c9c331914b';
        const CONTROL_DATA_UUID = 'beb5483e-36e1-4688-b7f5-ea07361b26a8';
        const CAPABILITY_DATA_UUID = '3dbcaa62-c2e1-48f9-af64-45047ff35662';

        /**
         * Byte protocol (per firmware/bluetooth.cpp):
         * [0] Left intensity (0-255)
         * [1] Right intensity (0-255)
         * [2] Forward intensity (0-255)
         * [3] Backward intensity (0-255)
         * [4] Others bitfield:
         *      bit0: headlamp toggle on transition
         *      bit1: horn toggle on transition
         */

        let bleDevice = null;
        let gattServer = null;
        let controlCharacteristic = null;
        let capabilityCharacteristic = null;

        const connectionStatus = document.getElementById('connectionStatus');
        const connectButton = document.getElementById('connectButton');
        const disconnectButton = document.getElementById('disconnectButton');
        const speedRange = document.getElementById('speedRange');
        const speedValue = document.getElementById('speedValue');
        const btnUp = document.getElementById('btnUp');
        const btnDown = document.getElementById('btnDown');
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');
        const btnBrake = document.getElementById('btnBrake');
        const btnHeadlamp = document.getElementById('btnHeadlamp');
        const btnHorn = document.getElementById('btnHorn');
        const capabilitiesSpan = document.getElementById('capabilities');
        const gamepadStatus = document.getElementById('gamepadStatus');
        const gamepadDebug = document.getElementById('gamepadDebug');

        const state = {
            left: 0,
            right: 0,
            forward: 0,
            back: 0,
            others: 0,
            supported: {
                headlamp: false,
                horn: false,
                turnSignals: false,
                brake: false,
            }
        };

        function setConnectedUi(connected) {
            connectButton.disabled = connected;
            disconnectButton.disabled = !connected;
            btnUp.disabled = !connected;
            btnDown.disabled = !connected;
            btnLeft.disabled = !connected;
            btnRight.disabled = !connected;
            btnBrake.disabled = !connected;
            btnHeadlamp.disabled = !connected || !state.supported.headlamp;
            btnHorn.disabled = !connected || !state.supported.horn;
            speedRange.disabled = !connected;
        }

        function updateSpeedLabel() {
            speedValue.textContent = String(speedRange.value);
        }

        async function connect() {
            try {
                connectionStatus.textContent = 'Requesting device...';
                // Prefer name filter due to firmware advertising characteristic UUID instead of service UUID
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ name: '4WD-control-board' }, { namePrefix: '4WD' }],
                    optionalServices: [CONTROL_SERVICE_UUID]
                });
                bleDevice = device;
                bleDevice.addEventListener('gattserverdisconnected', onDisconnected);

                connectionStatus.textContent = 'Connecting...';
                gattServer = await bleDevice.gatt.connect();

                const service = await gattServer.getPrimaryService(CONTROL_SERVICE_UUID);
                controlCharacteristic = await service.getCharacteristic(CONTROL_DATA_UUID);
                // Capabilities are optional, best-effort
                try {
                    capabilityCharacteristic = await service.getCharacteristic(CAPABILITY_DATA_UUID);
                    const dv = await capabilityCharacteristic.readValue();
                    parseCapabilities(dv);
                } catch (e) {
                    capabilityCharacteristic = null;
                    state.supported.headlamp = true; // Assume available if not readable
                    state.supported.horn = true;
                    updateCapabilitiesUi();
                }

                connectionStatus.textContent = 'Connected to ' + (bleDevice.name || 'device');
                setConnectedUi(true);
            } catch (error) {
                console.error(error);
                connectionStatus.textContent = 'Connection failed: ' + (error?.message || String(error));
                setConnectedUi(false);
            }
        }

        function onDisconnected() {
            connectionStatus.textContent = 'Disconnected';
            setConnectedUi(false);
            controlCharacteristic = null;
            capabilityCharacteristic = null;
            gattServer = null;
            bleDevice = null;
            // Reset motion state
            state.left = state.right = state.forward = state.back = 0;
        }

        async function disconnect() {
            try {
                if (bleDevice && bleDevice.gatt.connected) {
                    await bleDevice.gatt.disconnect();
                }
            } catch (e) {
                console.warn('Error during disconnect', e);
            } finally {
                onDisconnected();
            }
        }

        // ---------- Gamepad / Wheel support ----------
        let gamepadIndex = null;
        let animationFrameId = null;
        let lastBleSentTs = 0;
        const BLE_SEND_INTERVAL_MS = 50; // throttle BLE writes

        // Track previous button states for edge detection
        let prevButtons = [];
        function setGamepadStatus(text) { gamepadStatus.textContent = text; }

        window.addEventListener('gamepadconnected', (e) => {
            if (gamepadIndex === null) {
                gamepadIndex = e.gamepad.index;
                setGamepadStatus('Connected: ' + (e.gamepad.id || 'gamepad'));
            }
        });
        window.addEventListener('gamepaddisconnected', (e) => {
            if (gamepadIndex === e.gamepad.index) {
                gamepadIndex = null;
                setGamepadStatus('No gamepad');
            }
        });

        function clamp01(v) { return Math.min(1, Math.max(0, v)); }
        function abs(v) { return v < 0 ? -v : v; }
        function to255(v) { return Math.round(clamp01(v) * 255); }

        function readGamepad() {
            const pads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gp = pads && gamepadIndex !== null ? pads[gamepadIndex] : null;
            return gp && gp.connected ? gp : null;
        }

        function axisOrButton(gp, axisIndex, buttonIndexFallback) {
            // Prefer analog button if present (Xbox triggers often in buttons[6]/[7])
            if (gp && gp.buttons && gp.buttons[buttonIndexFallback]) {
                const val = gp.buttons[buttonIndexFallback].value; // 0..1
                if (val > 0.01) return clamp01(val);
            }
            if (gp && gp.axes && gp.axes.length > axisIndex) {
                // Many wheels use -1 at rest for triggers: map [-1..1] to [0..1]
                const a = gp.axes[axisIndex];
                return clamp01((a + 1) / 2);
            }
            return 0;
        }

        function renderGamepadDebug(gp) {
            if (!gamepadDebug) return;
            if (!gp) {
                gamepadDebug.value = 'No gamepad';
                return;
            }
            const axes = (gp.axes || []).slice(0, 8).map(v => (Math.round(v * 100) / 100).toFixed(2)).join(', ');
            const btnVals = (gp.buttons || []).slice(0, 12).map((b, i) => `${i}:${(Math.round((b.value || 0) * 100) / 100).toFixed(2)}${b.pressed ? '*' : ''}`).join('  ');
            const pressed = (gp.buttons || []).map((b, i) => (b.pressed ? i : null)).filter(i => i !== null).join(', ');
            gamepadDebug.value = `ID: ${gp.id}\nAxes[0..]: ${axes}\nButtons(0..): ${btnVals}\nPressed: [${pressed}]`;
        }

        function gamepadLoop() {
            const gp = readGamepad();
            if (!gp) {
                setGamepadStatus('No gamepad');
                renderGamepadDebug(null);
            } else {
                setGamepadStatus('Connected: ' + (gp.id || 'gamepad'));
                renderGamepadDebug(gp);
            }

            if (controlCharacteristic) {
                // Read steering (axis 0, centered at 0)
                const steer = gp && gp.axes ? gp.axes[0] : 0; // -1..1, left negative
                const steerMag = Math.max(0, abs(steer) - 0.1); // deadzone 0.1
                const steerNorm = clamp01(steerMag / 0.9); // scale to 0..1 after deadzone

                // Read throttle and brake (prefer buttons 7/6, fallback to axes 5/2)
                const throttle = gp ? axisOrButton(gp, 5, 7) : 0; // 0..1
                const brake = gp ? axisOrButton(gp, 2, 6) : 0;    // 0..1

                // Buttons mapping: X (2) headlamp toggle on press; B (1) horn hold
                if (gp) {
                    const curButtons = gp.buttons.map(b => ({ pressed: !!b.pressed, value: b.value }));
                    if (prevButtons.length !== curButtons.length) prevButtons = new Array(curButtons.length).fill({ pressed: false, value: 0 });

                    // Headlamp: toggle on rising edge of button 2
                    const wasX = prevButtons[2]?.pressed || false;
                    const isX = curButtons[2]?.pressed || false;
                    if (!wasX && isX && state.supported.headlamp) {
                        state.others ^= (1 << 0);
                    }

                    // Horn: toggle on both edges of button 1 (press and release)
                    const wasB = prevButtons[1]?.pressed || false;
                    const isB = curButtons[1]?.pressed || false;
                    if (wasB !== isB && state.supported.horn) {
                        state.others ^= (1 << 1);
                    }

                    prevButtons = curButtons;
                }

                // Build directional state respecting firmware priority: left/right over forward/back
                const maxMagnitude = Number(speedRange.value) / 255;
                const steerIntensity = to255(steerNorm * maxMagnitude);
                const forwardIntensity = to255(throttle * maxMagnitude);
                const backIntensity = to255(brake * maxMagnitude);

                state.left = 0; state.right = 0; state.forward = 0; state.back = 0;
                if (steerIntensity > 0) {
                    if (steer < 0) state.left = steerIntensity; else state.right = steerIntensity;
                } else if (forwardIntensity > 0) {
                    state.forward = forwardIntensity;
                } else if (backIntensity > 0) {
                    state.back = backIntensity;
                }

                const now = performance.now();
                if (now - lastBleSentTs >= BLE_SEND_INTERVAL_MS) {
                    lastBleSentTs = now;
                    sendState();
                }
            }

            animationFrameId = window.requestAnimationFrame(gamepadLoop);
        }

        // Start gamepad loop by default
        if (animationFrameId === null) animationFrameId = window.requestAnimationFrame(gamepadLoop);

        function parseCapabilities(dataView) {
            // Expecting 2 bytes: [reserved, bitfield]
            const bitfield = dataView.getUint8(1);
            state.supported.headlamp = Boolean(bitfield & (1 << 0));
            state.supported.horn = Boolean(bitfield & (1 << 1));
            state.supported.turnSignals = Boolean(bitfield & (1 << 2));
            state.supported.brake = Boolean(bitfield & (1 << 3));
            updateCapabilitiesUi();
        }

        function updateCapabilitiesUi() {
            const parts = [];
            if (state.supported.headlamp) parts.push('Headlamp');
            if (state.supported.horn) parts.push('Horn');
            if (state.supported.turnSignals) parts.push('Turn Signals');
            if (state.supported.brake) parts.push('Brake');
            capabilitiesSpan.textContent = parts.length ? ('Capabilities: ' + parts.join(', ')) : '';
            btnHeadlamp.disabled = !gattServer || !state.supported.headlamp;
            btnHorn.disabled = !gattServer || !state.supported.horn;
        }

        async function sendState() {
            if (!controlCharacteristic) return;
            const payload = new Uint8Array([
                state.left & 0xFF,
                state.right & 0xFF,
                state.forward & 0xFF,
                state.back & 0xFF,
                state.others & 0xFF
            ]);
            try {
                await controlCharacteristic.writeValue(payload);
            } catch (e) {
                console.warn('writeValue failed, retrying with queue', e);
                try {
                    await controlCharacteristic.writeValue(payload);
                } catch (e2) {
                    console.error('writeValue failed twice', e2);
                }
            }
        }

        function pressedDirectional(direction) {
            const magnitude = Number(speedRange.value) | 0;
            state.left = state.right = state.forward = state.back = 0;
            if (direction === 'left') state.left = magnitude;
            if (direction === 'right') state.right = magnitude;
            if (direction === 'up') state.forward = magnitude;
            if (direction === 'down') state.back = magnitude;
            sendState();
        }

        function releasedDirectional() {
            state.left = state.right = state.forward = state.back = 0;
            sendState(); // All zeros -> BRAKE event per firmware
        }

        function toggleHeadlamp() {
            // Bit 0 toggle triggers single HEAD_LAMP event on device side
            state.others ^= (1 << 0);
            sendState();
        }

        function hornPress() {
            // Toggle bit 1 ON press
            state.others ^= (1 << 1);
            sendState();
        }

        function hornRelease() {
            // Toggle bit 1 OFF release (restores previous bit)
            state.others ^= (1 << 1);
            sendState();
        }

        // UI wiring
        connectButton.addEventListener('click', connect);
        disconnectButton.addEventListener('click', disconnect);
        speedRange.addEventListener('input', updateSpeedLabel);

        // Pointer events for better mobile/desktop support
        function bindDirectional(btn, dir) {
            btn.addEventListener('pointerdown', (e) => { e.preventDefault(); pressedDirectional(dir); });
            btn.addEventListener('pointerup', (e) => { e.preventDefault(); releasedDirectional(); });
            btn.addEventListener('pointercancel', (e) => { e.preventDefault(); releasedDirectional(); });
            btn.addEventListener('pointerleave', (e) => { e.preventDefault(); releasedDirectional(); });
        }
        bindDirectional(btnUp, 'up');
        bindDirectional(btnDown, 'down');
        bindDirectional(btnLeft, 'left');
        bindDirectional(btnRight, 'right');

        btnBrake.addEventListener('click', releasedDirectional);
        btnHeadlamp.addEventListener('click', toggleHeadlamp);
        btnHorn.addEventListener('pointerdown', (e) => { e.preventDefault(); hornPress(); });
        btnHorn.addEventListener('pointerup', (e) => { e.preventDefault(); hornRelease(); });
        btnHorn.addEventListener('pointercancel', (e) => { e.preventDefault(); hornRelease(); });

        // Keyboard arrows support
        window.addEventListener('keydown', (e) => {
            if (!gattServer) return;
            if (e.repeat) return;
            if (e.key === 'ArrowUp') pressedDirectional('up');
            if (e.key === 'ArrowDown') pressedDirectional('down');
            if (e.key === 'ArrowLeft') pressedDirectional('left');
            if (e.key === 'ArrowRight') pressedDirectional('right');
            if (e.key.toLowerCase() === 'h') toggleHeadlamp();
            if (e.key.toLowerCase() === ' ') releasedDirectional();
        });
        window.addEventListener('keyup', (e) => {
            if (!gattServer) return;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) releasedDirectional();
        });

        // Prime status once
        setGamepadStatus('No gamepad');

        updateSpeedLabel();
        setConnectedUi(false);
    </script>
</body>
</html>
